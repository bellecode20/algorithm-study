# 체육 대회

### 문제
최대 10명의 학생과 10개의 종목이 있다.

모든 종목에는 겹치지 않게 1명의 학생이 출전하여야한다.

가장 높은 능력치의 합계를 구하세요.

### 생각해볼 점
기본적으로는 10!의 경우의 수를 따져봐야하고 이는 충분히 작은 시간 복잡도이다.

하지만 이는 불필요하게 계산되는 부분이 많은 것을 알 수 있다.

예를 들어 3명에게 테니스, 탁구, 수영에 대해서 역할 배분을 한다고 해보자.

3번째 사람에게 수영을 할당해서 가장 높은 점수를 받는 방법을 계산한다면

테니스-탁구-수영, 탁구-테니스-수영을 모두 계산하는 대신, max(테니스,탁구) + 수영으로 계산하는 것이 빠르다.

과목이 5개만 되어도 첫 번째 방법으로는 24가지 계산을 해야하는 반면, 두번째는 한 번의 계산으로 처리되는 것을 알 수 있다.

### 풀이
1. 10명에 대한 DP를 사용하였다.
2. DP[i](코드에서의 변수명은 dic)는 0~i번의 사람을 써서 얻을 수 있는 최대점수가 저장되어있다.
3. DP[i]는 10Ci개의 경우의 수를 가진다. 
   1. 예를 들어 DP[0]은 사람이 0명이므로 하나의 경우의 수만 가진다.
   2. DP[2]는 2명의 사람이므로 10C2가지 경우에 대한 각각의 최댓값이 저장되어있다.
   3. 따라서 처리해야하는 DP 칸의 개수는 2^10 = 1024개이다. (최대 2^N)
   4. 참고) 다루는 종목의 개수가 사람 수 보다 적더라도 0의 점수를 가지는 가상 종목을 사용하였다.

4. DP[i][j]에서 j는 종목의 조합을 나타낸다. ex) (테니스,탁구,수영)
   1. DP[i][j]를 구하는 방법은 max(j조합에서 과목 하나를 뺀 경우의 최댓값 + 새로 들어온 사람의 해당 과목 능력치)이다.
   2. ex) max( (테니스,탁구)+ability[i][수영], (테니스,수영)+ability[i][탁구], (탁구,수영)+ability[i][테니스] )
   3. DP[i][j]의 하나의 칸을 채우기 위해서는 i만큼의 계산이 필요하다. (최대 N)

5. 마지막으로 DP[N]에 있는 값을 가져오면 된다.
6. 전체 시간 복잡도는 N 2^N 이하이다. N=10인 경우 10240이므로 기존의 10!=36만에 비해서 36배 빠르다.



```python
def solution(ability):
    # 1. 빈 과목에 0점 할당
    # 2. 전체 경우의 수는 과목을 채택했고말고
    # 3. 그럼 경우의 수는 1024개
    # 4. 그럼 1024개에 대한 DP를 생성 가능
    # 5. 사람은 한 명 씩 추가해가기
    # 6. 조금 더 직관적인 방법...
    # 7. 가시적으로 표현하자.
    # 8. 
    N = len(ability)
    M = N-len(ability[0])
    for i in ability:
        for j in range(M):
            i.append(0)

    dic = [{} for _ in range(N+1)]

    for i in range(1<<N):
        cnt = 0
        for j in range(N):
            if i &(1<<j):
                cnt += 1  
        dic[cnt][i] = 0 # 점수
    
    for i in range(N): # 사람 번호
        cur_dic = dic[i]
        for j in range(N): # 과목 번호 
            for k in cur_dic:
                if k&(1<<j): continue # 해당 과목 처리한 경우
                dic[i+1][k^(1<<j)] = max(dic[i+1][k^(1<<j)], cur_dic[k]+ability[i][j])

    return dic[-1][(1<<N)-1]
```